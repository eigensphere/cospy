'''

THIS IS A CODE GENERATED BY
Cospy/cospy/equation_factory.py
DON'T MODIFY IT

'''


import logging
import numpy as np 
from numpy import exp, sin, cos, tan 
from scipy.integrate import simps 

import pygsl._numobj as Numeric
import cospy.utils as cp_utils

class Problem(object):
    '''
    classdocs
    '''


    def __init__(self,params):
        '''
        Constructor
        '''
        self.M = 2.0622

        self.id_file = params.get('id file')

        self.id_kind = params.get('initial data')



        if self.id_kind == 'ground state':
            
            self.r1x = params.getfloat('position x-direction',0)
            self.r1y = params.getfloat('position y-direction',0)
            self.r1z = params.getfloat('position z-direction',0)

            self.p1x = params.getfloat('momentum x-direction',0)
            self.p1y = params.getfloat('momentum y-direction',0)
            self.p1z = params.getfloat('momentum z-direction',0)

            logging.info('Solving Schroedinger-Poisson system - ground state ')
            logging.info('Initial position: x=%f, y=%f, z=%f ',self.r1x,self.r1y,self.r1z)
            logging.info('Initial momentum: Px=%f, Py=%f, Pz=%f ',self.p1x,self.p1y,self.p1z)

        elif  self.id_kind == 'binary ground state':


            self.r1x = params.getfloat('position 1 x-direction',-5)
            self.r1y = params.getfloat('position 1 y-direction',0)
            self.r1z = params.getfloat('position 1 z-direction',0)

            self.p1x = params.getfloat('momentum 1 x-direction',0)
            self.p1y = params.getfloat('momentum 1 y-direction',0.05)
            self.p1z = params.getfloat('momentum 1 z-direction',0)
            
            self.r2x = params.getfloat('position 2 x-direction',5)
            self.r2y = params.getfloat('position 2 y-direction',0)
            self.r2z = params.getfloat('position 2 z-direction',0)

            self.p2x = params.getfloat('momentum 2 x-direction',0)
            self.p2y = params.getfloat('momentum 2 y-direction',-0.05)
            self.p2z = params.getfloat('momentum 2 z-direction',0)

            logging.info('Solving Schroedinger-Poisson system - binary ground state ')
            logging.info('Initial position: x1=%f, y1=%f, z1=%f ',self.r1x,self.r1y,self.r1z)
            logging.info('Initial momentum: Px1=%f, Py1=%f, Pz1=%f ',self.p1x,self.p1y,self.p1z)
            logging.info('Initial position: x2=%f, y2=%f, z2=%f ',self.r2x,self.r1y,self.r1z)
            logging.info('Initial momentum: Px2=%f, Py2=%f, Pz2=1%f ',self.p2x,self.p2y,self.p2z)


        sponge_r = params.getfloat('sponge radius percentage',0.9)
        self.sponge_h = abs(params.getfloat('sponge depth',1))

        if sponge_r < 0.3 :
            self.sponge_r = 0.3
        elif sponge_r > 1 :
            self.sponge_r = 1
        else:
            self.sponge_r = sponge_r

       
    def get_fields(self):
        return {'U': 'elliptic', 'psiR': 'hyperbolic', 'psiI': 'hyperbolic', 'UI' : 'parameter', 'rho' : 'parameter'}

    

    def set_initial_data(self,grid):

        for level in np.arange(grid._mg_levels-1):
            
            x, y, z = grid.get_coordinates(level)

            if self.id_kind == 'ground state':
                grid['psiR',level], grid['psiI',level] = self.id_ground(x, y, z)
                
            elif  self.id_kind == 'binary ground state':
                grid['psiR',level], grid['psiI',level] = self.id_binary(x, y, z)            
                
            else:
                raise Exception('Initial data type not implemented')

            grid['UI',level] = self.sponge(x, y, z)            

   
         
    def id_binary(self,x,y,z):
        
        r1=np.sqrt((x-self.r1x)**2+(y-self.r1y)**2+(z-self.r1z)**2)
        r2=np.sqrt((x-self.r2x)**2+(y-self.r2y)**2+(z-self.r2z)**2)

        Rf = self.sponge_r * 0.5*( np.max(r1)+np.max(r2))

        p_dot_r1 = self.p1x * (x - self.r1x) + self.p1y * (y - self.r1y) + self.p1z * (z - self.r1z)
        r1_2=r1**2
        real_ground_1 =  0.5*(1-np.tanh(r1-Rf))*(0.440793*exp(-0.252654*r1_2)+
                                          0.389635*exp(-0.125657*r1_2)+
                                          0.10133*exp(-0.5112*r1_2)+
                                          0.0344551*exp(-0.0633156*(r1+0.397224)*(r1+0.397224))+
                                          0.0344551*exp(-0.0633156*(r1-0.397224)*(r1-0.397224)))

        p_dot_r2 = self.p2x * (x - self.r2x) + self.p2y * (y - self.r2y) + self.p2z * (z - self.r2z)         
        r2_2=r2**2
        real_ground_2 =  0.5*(1-np.tanh(r2-Rf))*(0.440793*exp(-0.252654*r2_2)+
                                          0.389635*exp(-0.125657*r2_2)+
                                          0.10133*exp(-0.5112*r2_2)+
                                          0.0344551*exp(-0.0633156*(r2+0.397224)*(r2+0.397224))+
                                          0.0344551*exp(-0.0633156*(r2-0.397224)*(r2-0.397224)))

        return np.cos(p_dot_r1)*real_ground_1+np.cos(p_dot_r2)*real_ground_2, np.sin(p_dot_r1)*real_ground_1+np.sin(p_dot_r2)*real_ground_2 



    def id_ground(self,x,y,z):
        
        r=np.sqrt((x-self.r1x)**2+(y-self.r1y)**2+(z-self.r1z)**2)
        Rf = self.sponge_r * np.max(r)

        p_dot_r1 = self.p1x * (x - self.r1x) + self.p1y * (y - self.r1y) + self.p1z * (z - self.r1z)
 
        r2=r**2        
        real_ground_1 = 0.5*(1-np.tanh(r-Rf))*(0.440793*exp(-0.252654*r2)+
                                          0.389635*exp(-0.125657*r2)+
                                          0.10133*exp(-0.5112*r2)+
                                          0.0344551*exp(-0.0633156*(r+0.397224)*(r+0.397224))+
                                          0.0344551*exp(-0.0633156*(r-0.397224)*(r-0.397224)))

        return np.cos(p_dot_r1)*real_ground_1, np.sin(p_dot_r1)*real_ground_1


    def sponge(self, x, y , z):
        
        r=np.sqrt(x**2+y**2+z**2)
        Rf = self.sponge_r * np.max(r)
        delta = 0.5*(1-self.sponge_r)
        
        return -0.5*self.sponge_h*(2+np.tanh((r-Rf)/delta) - np.tanh(Rf/delta))
            
    def rhs(self,_t, _y, grid):


        grid.set_mol_fields(_y)
         
        rhs = dict()
                            
        rhs['psiR'] = self.rhs_psiR(grid.lap('psiI'),grid['psiR'],grid['psiI'],grid['U'],grid['UI'])        
        rhs['psiI'] = self.rhs_psiI(grid.lap('psiR'),grid['psiR'],grid['psiI'],grid['U'],grid['UI'])        

        
        f = grid.get_rhs(rhs)
    
        return f.ravel()


    
    def rhs_psiR(self,lap_psiI,psiR,psiI,U,UI):
        return -0.5*lap_psiI+U*psiI+UI*psiR

    def rhs_psiI(self,lap_psiR,psiR,psiI,U,UI):
        return 0.5*lap_psiR+UI*psiI-U*psiR


    def rhs_jac(self,t, y, m):

        logging.error('rhs_jac not implemented')
        exit()


    def mg_problem(self):
        
        mgp = dict()
        
        mgs_U = dict() 
        
        mgs_U['source'] = self.U_source

        mgs_U['operator'] = self.U_operator

        mgs_U['diff_operator'] = self.U_diff_operator

        
        mgp['U'] = mgs_U
            
        return mgp
    
     
    def U_source(self,grid,level):

        grid['rho',level] =  grid['psiR',level]**2+grid['psiI',level]**2 
        
        x, y , z = grid.get_coordinates(level)

        s = -self.M/(np.sqrt(x**2+y**2+z**2)+1e-8 )
        
        bbx = grid.parse_index('b',level,0)
        bby = grid.parse_index('b',level,1)
        bbz = grid.parse_index('b',level,2)
        
        for bx in bbx:
            grid[bx,:,:,'rho',level] = s[bx,:,:] 
            for by in bby:
                grid[bx,by,:,'rho',level] = s[bx,by,:] 
                
                for bz in bbz:
                    grid[bx,by,bz,'rho',level] = s[bx,by,bz] 

            for bz in bbz:
                grid[bx,:,bz,'rho',level] = s[bx,:,bz] 

        for by in bby:
            grid[:,by,:,'rho',level] = s[:,by,:] 
            
            for bz in bbz:
                grid[:,by,bz,'rho',level] = s[:,by,bz] 
            
        for bz in bbz:
            grid[:,:,bz,'rho',level] = s[:,:,bz] 

        return grid['rho',level]


    def U_operator(self,grid,level):
        
        Lv = grid.lap('U',level)
        
        u= grid['U',level] 

        bbx = grid.parse_index('b',level,0)
        bby = grid.parse_index('b',level,1)
        bbz = grid.parse_index('b',level,2)
        
        for bx in bbx:
            Lv[bx,:,:] = u[bx,:,:] 
            for by in bby:
                Lv[bx,by,:] = u[bx,by,:] 
                
                for bz in bbz:
                    Lv[bx,by,bz] = u[bx,by,bz] 

            for bz in bbz:
                Lv[bx,:,bz] = u[bx,:,bz] 
                
        for by in bby:
            Lv[:,by,:] = u[:,by,:] 
            
            for bz in bbz:
                Lv[:,by,bz] = u[:,by,bz] 
                
        for bz in bbz:
            Lv[:,:,bz] = u[:,:,bz] 



        return Lv

    def U_diff_operator(self,grid,level):

        dLv = grid.dlap_du('U',level)

        bbx = grid.parse_index('b',level,0)
        bby = grid.parse_index('b',level,1)
        bbz = grid.parse_index('b',level,2)
        
        for bx in bbx:
            dLv[bx,:,:] = 1

            for by in bby:
                dLv[bx,by,:] = 1 
                for bz in bbz:
                    dLv[bx,by,bz] = 1 
            for bz in bbz:
                dLv[bx,:,bz] = 1 

        for by in bby:
            dLv[:,by,:] = 1 
            for bz in bbz:
                dLv[:,by,bz] = 1

        for bz in bbz:
            dLv[:,:,bz] = 1 



        return dLv

    def analysis(self,grid,t):

        rho = grid['i','i','i','rho']
        U = grid['i','i','i','U']
        psiR = grid['i','i','i','psiR']
        psiI = grid['i','i','i','psiI']
        lap_psiR = grid.lap('i','i','i','psiR')
        lap_psiI = grid.lap('i','i','i','psiI')

        
        ix = grid.parse_index('i',0,0)
        iy = grid.parse_index('i',0,1)
        iz = grid.parse_index('i',0,2)
        
        x, y , z = grid.get_coordinates()
        
        Mz=simps(rho, z[ix,iy,iz], axis=2, even='first')
        My=simps(Mz, y[ix,iy,0], axis=1, even='first')
        M=simps(My, x[ix,0,0], axis=0, even='first')
        
        Wz=simps(rho*U, z[ix,iy,iz], axis=2, even='first')
        Wy=simps(Wz, y[ix,iy,0], axis=1, even='first')
        W=simps(Wy, x[ix,0,0], axis=0, even='first')
        
        Kz=simps(psiR*lap_psiR+psiI*lap_psiI, z[ix,iy,iz], axis=2, even='first')
        Ky=simps(Kz, y[ix,iy,0], axis=1, even='first')
        K=simps(Ky, x[ix,0,0], axis=0, even='first')
        
        return {'M' : M/(4*np.pi), 'W' : 0.5*W/(4*np.pi), 'K' : -0.5*K/(4*np.pi)} 
        
        
        
        