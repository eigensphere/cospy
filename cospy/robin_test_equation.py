'''

THIS IS A CODE GENERATED BY
Cospy/cospy/equation_factory.py
DON'T MODIFY IT

'''

import logging
import numpy as np 
from numpy import exp, sin, cos, tan 

import pygsl._numobj as Numeric
import cospy.utils as cp_utils

class Problem(object):
    '''
    classdocs
    '''


    def __init__(self,params):
        '''
        Constructor
        '''
        
        self.h = params.getfloat('gaussian amplitude',1)

        self.sigma2 = params.getfloat('gaussian sigma',1)**2
       
       
    def get_fields(self):
        return {'v': 'elliptic', 'rho': 'hyperbolic'}
    

    def set_initial_data(self,grid):


        for level in np.arange(grid._mg_levels-1):
            x, y, z = grid.get_coordinates(level)
            grid['rho',level] = self.id_rho(x, y, z)

   
        
    
    def id_rho(self,x,y,z): 

        r=np.sqrt(x**2+y**2+z**2)
        
        return 2*self.h*(np.tanh(r)**2-np.tanh(r))/r

         
            
    def rhs(self,_t, _y, grid):


        grid.set_mol_fields(_y)
         
        rhs = dict()
                               
        rhs['rho'] = self.rhs_rho(grid['rho'])        
        
        f = grid.get_rhs(rhs)
    
        return f.ravel()


    def rhs_rho(self,rho):
        return -rho


    def rhs_jac(self,t, y, m):

        logging.error('rhs_jac not implemented')
        exit()


    def mg_problem(self):
        
        mgp = dict()

        mgs_v = dict() 
        
        mgs_v['source'] = self.v_source

        mgs_v['operator'] = self.v_operator

        mgs_v['diff_operator'] = self.v_diff_operator
        
        mgp['v'] = mgs_v
            
        return mgp
    
    


    def v_source(self,grid,level):

        v_s = grid['rho',level]

        
        bx = grid.parse_index('b',level,0)
        by = grid.parse_index('b',level,1)
        bz = grid.parse_index('b',level,2)
        
        v_s[bx,:,:] = 0
        v_s[:,by,:] = 0 
        v_s[:,:,bz] = 0 

        v_s[bx,by,:] = 0 
        v_s[:,by,bz] = 0 
        v_s[bx,:,bz] = 0 

        v_s[bx,by,bz] = 0 
        
        return v_s


    def v_operator(self,grid,level):
        
        Lv = grid.lap('v',level)
        
        u= grid['v',level] 

        bx = grid.parse_index('b',level,0)
        by = grid.parse_index('b',level,1)
        bz = grid.parse_index('b',level,2)
        
        Lv[bx,:,:] = u[bx,:,:] - grid.shift_diff(bx,:,:,'v',level)
        Lv[:,by,:] = u[:,by,:] - grid.shift_diff(:,by,:,'v',level)
        Lv[:,:,bz] = u[:,:,bz] - grid.shift_diff(:,:,bz,'v',level)

        Lv[bx,by,:] = u[bx,by,:] 
        Lv[:,by,bz] = u[:,by,bz] 
        Lv[bx,:,bz] = u[bx,:,bz] 

        Lv[bx,by,bz] = u[bx,by,bz] 

        return Lv

    def v_diff_operator(self,grid,level):

        dLv = grid.dlap_du('v',level)

        bx = grid.parse_index('b',level,0)
        by = grid.parse_index('b',level,1)
        bz = grid.parse_index('b',level,2)
        
        dLv[bx,:,:] = 1
        dLv[:,by,:] = 1 
        dLv[:,:,bz] = 1 

        dLv[bx,by,:] = 1 
        dLv[:,by,bz] = 1
        dLv[bx,:,bz] = 1 

        dLv[bx,by,bz] = 1 

        return dLv


